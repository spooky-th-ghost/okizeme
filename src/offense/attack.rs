use crate::*;
use bevy::prelude::*;

#[derive(Debug, Clone)]
pub struct Attack {
    pub name: String,
    pub total_frames: u8,
    pub attack_events: Vec<AttackEvent>,
    pub leaves_counterhit: Option<u8>,
}

#[derive(Component)]
pub struct AttackController {
    pub counter_hit: bool,
    pub cancellable: bool,
    pub frame: u8,
    pub attack: Attack,
}

impl AttackController {
    pub fn update(&mut self) -> Option<Vec<AttackEvent>> {
        self.frame += 1;
        self.leave_counterhit();
        self.get_attack_events_this_frame()
    }

    pub fn is_expired(&self) -> bool {
        self.frame == self.attack.total_frames
    }

    fn get_attack_events_this_frame(&self) -> Option<Vec<AttackEvent>> {
        let mut events_to_return = Vec::new();

        for attack_event in self.attack.attack_events.iter() {
            if self.frame == attack_event.frame {
                events_to_return.push(*attack_event);
            }
        }
        (events_to_return.len() != 0).then_some(events_to_return)
    }

    fn leave_counterhit(&mut self) {
        if let Some(frame) = self.attack.leaves_counterhit {
            if self.frame == frame {
                self.counter_hit = false
            }
        }
    }
}

impl Default for Attack {
    fn default() -> Self {
        Attack {
            name: "none".to_string(),
            total_frames: 0,
            attack_events: Vec::new(),
            leaves_counterhit: None,
        }
    }
}
/// Struct that defines the frame that a hitbox should be generated by an attack
#[derive(Debug, Default, Clone, Copy)]
pub struct AttackEvent {
    pub frame: u8,
    pub hitbox: Hitbox,
    pub location: Vec2,
    pub size: Vec2,
}
