use crate::*;
use bevy::prelude::*;

pub struct Skill {
    skill_type: SkillType,
    skill_state: SkillState,
    skill_motion: SkillMotion,
    skill_button: SkillButton,
}

pub enum SkillType {
    Normal,
    Special,
    Super,
}

pub enum SkillState {
    Ground,
    Air,
}

pub enum MotionType {
    Normal,
    Special,
    Super,
}

#[allow(non_camel_case_types)]
pub enum SkillMotion {
    m_236,
    m_214,
    m_623,
    m_421,
    m_22,
    m_5,
    m_4,
    m_6,
    m_2,
    m_3,
    m_1,
}

impl SkillMotion {
    pub fn is_normal(&self) -> bool {
        use SkillMotion::*;
        match self {
            m_5 | m_4 | m_6 | m_2 | m_1 | m_3 => true,
            _ => false,
        }
    }

    pub fn is_special(&self) -> bool {
        use SkillMotion::*;
        match self {
            m_236 | m_214 | m_623 | m_421 | m_22 => true,
            _ => false,
        }
    }
}

#[allow(non_camel_case_types)]
pub enum SkillButton {
    b_a,
    b_b,
    b_c,
    b_d,
    b_e,
    b_f,
    b_g,
    b_h,
}

#[derive(Debug, Eq, PartialEq)]
pub enum CommandMotion {
    Dash,
    Backdash,
    Qcf,
    Qcb,
    Dp,
    Rdp,
    TwoTwo,
    DoubleQcf,
}

#[derive(Debug, Clone)]
pub struct Attack {
    pub name: String,
    pub total_frames: u8,
    pub attack_events: Vec<AttackEvent>,
    pub leaves_counterhit: Option<u8>,
}

#[derive(Component)]
pub struct AttackController {
    pub counter_hit: bool,
    pub cancellable: bool,
    pub frame: u8,
    pub attack: Attack,
}

impl AttackController {
    pub fn update(&mut self) -> Option<Vec<AttackEvent>> {
        self.frame += 1;
        self.leave_counterhit();
        self.get_attack_events_this_frame()
    }

    pub fn is_expired(&self) -> bool {
        self.frame == self.attack.total_frames
    }

    fn get_attack_events_this_frame(&self) -> Option<Vec<AttackEvent>> {
        let mut events_to_return = Vec::new();

        for attack_event in self.attack.attack_events.iter() {
            if self.frame == attack_event.frame {
                events_to_return.push(*attack_event);
            }
        }
        (events_to_return.len() != 0).then_some(events_to_return)
    }

    fn leave_counterhit(&mut self) {
        if let Some(frame) = self.attack.leaves_counterhit {
            if self.frame == frame {
                self.counter_hit = false
            }
        }
    }
}

impl Default for Attack {
    fn default() -> Self {
        Attack {
            name: "none".to_string(),
            total_frames: 0,
            attack_events: Vec::new(),
            leaves_counterhit: None,
        }
    }
}
/// Struct that defines the frame that a hitbox should be generated by an attack
#[derive(Debug, Default, Clone, Copy)]
pub struct AttackEvent {
    pub frame: u8,
    pub hitbox: Hitbox,
    pub location: Vec2,
    pub size: Vec2,
}
