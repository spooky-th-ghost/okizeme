use bevy::prelude::*;
use serde::{Deserialize, Serialize};
use okizeme_utils::*;
use crate::{
  Hurtbox,
  BlockState,
  Collision
};

/// Box generated by attacks in game
#[cfg_attr(feature = "debug", derive(bevy_inspector_egui::Inspectable))]
#[derive(Component,Debug, Clone, Copy, Default)]
pub struct Hitbox {
  /// Attack level, effects hit/block stun
  attack_level: u8,
  /// Base damage of the hitbox
  damage: u8,
  /// Proration when this hitbox connects first in a combo
  proration: f32,
  /// Force to be applied when a player is hit by this
  force: Vec2,
  /// Has the hitbox connected
  hit_state: HitState,
  /// Can the hitbox be blocked in the air
  air_blockable: bool,
  /// The block property of the hitbox
  property: HitboxProperty,
  /// How many frames will this hitbox stay out
  duration: u8,
  /// Does this hitbox cause damage when blocked
  chip: bool,
  /// Is the hitbox currently active
  active: bool,
  /// Is the hitbox attached to the player that generated it
  projectile: bool,
}

impl Hitbox {
  /// Create a hitbox from it's serialized counterpart
  pub fn from_serialized(s: HitboxSerialized) -> Self {
    Hitbox {
      attack_level: s.attack_level,
      damage: s.damage,
      proration: s.proration,
      force: s.force.to_vec2(),
      air_blockable: s.air_blockable,
      property: s.property,
      duration: s.duration,
      chip: s.chip,
      projectile: s.projectile,
      hit_state: HitState::None,
      active: false
    }
  }

  /// if possible, lower the hitboxes duration by 1 frame
  pub fn tick(&mut self) {
    self.duration = countdown(self.duration);
  }

  /// return if the hitbox should be removed
  pub fn is_finished(&self) -> bool {
    return self.duration == 0;
  }

  pub fn generate_collision(&self, hurtbox: &Hurtbox) -> Collision {
    return Collision::new(self.clone(), self.is_blocked(hurtbox));
  }

  /// Returns if a Hitbox is blocked by a Hurtbox it overlaps
  pub fn is_blocked(&self, hurtbox: &Hurtbox) -> bool {
    use HitboxProperty::*;
    use BlockState::*;
    match hurtbox.block_state {
      Stand {barrier:_, instant:_} => {
        match self.property {
          Low => return false,
          _ => return true
        }
      },
      Crouch {barrier:_, instant:_} => {
        match self.property {
          High => return false,
          _ => return true
        }
      },
      Air {barrier, instant:_} => {
        if self.air_blockable {
          return true
        } else {
          if barrier {
            return true
          } else {
            return false
          }
        }
      },
      None => return false,
    }
  }
}


#[cfg_attr(feature = "debug", derive(bevy_inspector_egui::Inspectable))]
#[derive(Deserialize, Serialize, Debug, Clone, Copy)]
pub enum HitboxProperty {
  Mid,
  Low,
  High,
}

impl Default for HitboxProperty {
  fn default() -> Self {
    HitboxProperty::Mid
  }
}

/// Serialized version of a hitbox
#[derive(Deserialize, Serialize)]
pub struct HitboxSerialized {
  pub name: String,
  pub attack_level: u8,
  pub damage: u8,
  pub proration: f32,
  pub force: Vec2Serialzed,
  pub air_blockable: bool,
  pub property: HitboxProperty,
  pub duration: u8,
  pub chip: bool,
  pub projectile: bool,
}

#[derive(Deserialize, Serialize)]
pub struct Vec2Serialzed {
  pub x: f32,
  pub y: f32,
}

#[cfg_attr(feature = "debug", derive(bevy_inspector_egui::Inspectable))]
#[derive(Debug, Clone, Copy)]
pub enum HitState {
  None,
  Hit,
  Blocked
}
