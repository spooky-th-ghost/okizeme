use bevy::prelude::*;
use serde::{Deserialize, Serialize};
use bevy_inspector_egui::Inspectable;
use okizeme_utils::{
  countdown
};
use okizeme_types::{
  PlayerId
};
use okizeme_defense::{
  Hurtbox,
  BlockState,
};
use crate::{
  Collision
};

/// Box generated by attacks in game
#[derive(Component,Debug, Clone, Copy, Default,Inspectable)]
pub struct Hitbox {
  /// Base damage of the hitbox
  damage: u8,
  /// Proration when this hitbox connects first in a combo
  proration: f32,
  /// Force to be applied when a player is hit by this
  force: Vec2,
  /// Has the hitbox connected
  hit_state: HitState,
  /// Can the hitbox be blocked in the air
  air_blockable: bool,
  /// The block property of the hitbox
  property: AttackProperty,
  /// Strength of attack, used for hitstop/hitstun values
  level: AttackLevel,
  /// How many frames will this hitbox stay out
  duration: u8,
  /// Does this hitbox cause damage when blocked
  chip: bool,
  /// Is the hitbox currently active
  active: bool,
  /// Is the hitbox attached to the player that generated it
  projectile: bool,
}

impl Hitbox {
  // Mutations
  /// if possible, lower the hitboxes duration by 1 frame
  pub fn tick(&mut self) {
    self.duration = countdown(self.duration);
  }

  /// Set hitbox to inactive
  pub fn deactivate(&mut self) {
    self.active = false;
  }

  // Getters
  /// Is the hitbox currently active?
  pub fn active(&self) -> bool {
    self.active
  }

  /// Is the hitbox a projectile
  pub fn projectile(&self) -> bool {
    self.projectile
  }

  /// Should the hitbox be removed
  pub fn finished(&self) -> bool {
    return self.duration == 0;
  }

  /// Base damage for the hitbox
  pub fn damage(&self) -> u8 {
    self.damage
  }

  /// Base proration for the hitbox
  pub fn proration(&self) -> f32 {
    self.proration
  }

  /// Attack Level
  pub fn level(&self) -> AttackLevel {
    self.level
  }

  pub fn generate_collision(&self, hurtbox: &Hurtbox) -> Collision {
    return Collision::new(self.clone(), self.is_blocked(hurtbox));
  }

  /// Returns if a Hitbox is blocked by a Hurtbox it overlaps
  pub fn is_blocked(&self, hurtbox: &Hurtbox) -> bool {
    use AttackProperty::*;
    use BlockState::*;
    match hurtbox.block_state {
      Stand {barrier:_, instant:_} => {
        match self.property {
          Low => return false,
          _ => return true
        }
      },
      Crouch {barrier:_, instant:_} => {
        match self.property {
          High => return false,
          _ => return true
        }
      },
      Air {barrier, instant:_} => {
        if self.air_blockable {
          return true
        } else {
          if barrier {
            return true
          } else {
            return false
          }
        }
      },
      None => return false,
    }
  }
}


//#[cfg_attr(feature = "debug", derive(bevy_inspector_egui::Inspectable))]
#[derive(Deserialize, Serialize, Debug, Clone, Copy, Component,Inspectable)]
pub enum AttackProperty {
  Mid,
  Low,
  High,
}

impl Default for AttackProperty {
  fn default() -> Self {
    AttackProperty::Mid
  }
}

//#[cfg_attr(feature = "debug", derive(bevy_inspector_egui::Inspectable))]
#[derive(Debug, Clone, Copy, Inspectable)]
pub enum HitState {
  None,
  Hit,
  Blocked
}

impl Default for HitState {
  fn default() -> Self {
      HitState::None
  }
}

#[derive(Copy, Clone, Debug, Inspectable)]
pub enum AttackLevel {
  L0,
  L1,
  L2,
  L3,
  L4
}

impl Default for AttackLevel {
  fn default() -> Self {
      AttackLevel::L0
  }
}

pub enum Knockdown {
  None,
  Stand,
  Soft,
  Mid,
  Hard
}

pub struct StunValues {
  pub hitstop: u8,
  pub standing_hitstun: u8,
  pub crouching_hitstun: u8,
  pub aerial_hitstun: u8,
  pub blockstun: u8
}

impl StunValues {
  fn new(hitstop: u8, standing_hitstun: u8, crouching_hitstun: u8, aerial_hitstun: u8, blockstun: u8) -> Self {
    StunValues {
      hitstop,
      standing_hitstun,
      crouching_hitstun,
      aerial_hitstun,
      blockstun
    }
  }

  pub fn from_attack_level(attack_level: AttackLevel) -> Self {
    use AttackLevel::*;
    match attack_level {
      L0 => StunValues::new(11, 12, 13, 14, 9),
      L1 => StunValues::new(12, 14, 15, 16, 11),
      L2 => StunValues::new(13, 16, 17, 18, 13),
      L3 => StunValues::new(14, 19, 20, 21, 16),
      L4 => StunValues::new(15, 21, 22, 23, 18)
    }
  }
}

pub struct CancelEvent {
  pub player_id: PlayerId,
  pub cancel_trigger: CancelTrigger
}

pub enum CancelTrigger{
  Chain,
  Hit,
  Block
}

pub enum ComboedState{
  Standing,
  Crouching,
  Juggle
}
#[derive(Bundle)]
pub struct HitboxBundle {
  #[bundle]
  sprite_bundle: SpriteBundle,
  player_id: PlayerId,
  hitbox: Hitbox
}
